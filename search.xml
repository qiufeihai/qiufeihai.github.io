<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2017%2F05%2F03%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[容器属性 属性 描述 值 flex-direction 属性决定主轴的方向（即项目的排列方向）。 row / row-reverse / column / column-reverse flex-wrap 属性定义，如果一条轴线排不下，如何换行。 nowrap / wrap / wrap-reverse flex-flow 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-content 属性定义了项目在主轴上的对齐方式。 flex-start / flex-end / center / space-between / space-around align-items 属性定义项目在交叉轴上如何对齐。 flex-start / flex-end / center / baseline / stretch align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start / flex-end / center / space-between / space-around / stretch 项目属性 属性 描述 值 order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。 flex 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 auto / flex-start / flex-end / center / baseline / stretch 参考链接： Flex 布局教程：语法篇 Flex 布局教程：实例篇]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>flex</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何优雅安全地在深层数据结构中取值]]></title>
    <url>%2F2017%2F05%2F02%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%89%E5%85%A8%E5%9C%B0%E5%9C%A8%E6%B7%B1%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E5%8F%96%E5%80%BC%2F</url>
    <content type="text"><![CDATA[如果有如下数据const props = { user: { posts: [ { title: &apos;Foo&apos;, comments: [ &apos;Good one!&apos;, &apos;Interesting...&apos; ] }, { title: &apos;Bar&apos;, comments: [ &apos;Ok&apos; ] }, { title: &apos;Baz&apos;, comments: []} ], comments: [...] } } 以前props.user &amp;&amp; props.user.posts &amp;&amp; props.user.posts[0] &amp;&amp; props.user.posts[0].comments 现在1.写个javascript函数const get = (p, o) =&gt; p.reduce((xs, x) =&gt; (xs &amp;&amp; xs[x]) ? xs[x] : null, o) console.log(get([&apos;user&apos;, &apos;posts&apos;, 0, &apos;comments&apos;], props)) // [ &apos;Good one!&apos;, &apos;Interesting...&apos; ] console.log(get([&apos;user&apos;, &apos;post&apos;, 0, &apos;comments&apos;], props)) // null 2.使用Ramda提供的path或pathOr函数path const getUserComments = R.path([&apos;user&apos;, &apos;posts&apos;, 0, &apos;comments&apos;]) getUserComments(props) // [ &apos;Good one!&apos;, &apos;Interesting...&apos; ] getUserComments({}) // null pathOr const getUserComments = R.pathOr([], [&apos;user&apos;, &apos;posts&apos;, 0, &apos;comments&apos;]) getUserComments(props) // [ &apos;Good one!&apos;, &apos;Interesting...&apos; ] getUserComments({}) // [] pathOr可以在没有找到值时指定默认值 参考链接：如何优雅安全地在深层数据结构中取值]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>